### 알고리즘

- 문제를 해결하기 위해 수행해야 하는 절차나 방법
    - 컴퓨터 분야에서의 알고리즘 : 원하는 결과를 얻기 위해 프로그램이 수행해야 하는 절차

### APS (Algorithm Problem Solving)

- 알고리즘 문제
    - 구현력
    - 디버깅
    - 논리적 사고
    
- 정확성
- **작업량 ~ 실행 시간**
- 메모리 사용량
- 단순성
- 최적성

## 시간 복잡도 (Tiem Complexity)

- 실행되는 명령문의 개수를 계산

## 빅-오(O) 표기법 ( Big-Oh Notation)

- O(3n + 2) = O(n)
- O(2n^2 + 10N + 100) = O(n^2)
- O(4) = O(1) → 상수 시간 알고리즘

## 자료구조 : 데이터를 효율적으로 담는 방법

- 데이터의 추가, 조회, 수정, 삭제 연산을 최적화 하는 구조
- 프로그램의 목적에 따라 활용할 수 있는 다양한 자료구조가 존재
    - ex) Array, List, Stack, Queue, Tree….
- 효율적인 알고리즘을 구현하기 위해 효율적인 자료구조가 필수

## 정렬의 종류

- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 카운팅 정렬
- 병합 정렬
- 퀵 정렬

## Array

- Collections.sort()
- Arrays.sort()
- Comparable<T>
- Comparator<T>

### 탐색 키 (Search Key) : 자료를 구별하여 인식할 수 있는 키

- 순차 검색 (Sequential Search)
    - 알고리즘이 단순해 구현이 쉽지만, 대상의 수가 많은 경우 수행 시간이 급격히 증가해 비효율적임
- 이진 검색 (Binary Search)
    - 자료의 ***가운데***에 있는 항목의 키 값과 비교해 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - O(logN)
- 인덱싱

```java
for(int i = 0 ; i < arr.length; i++){
		if(key == arr[i]){
				return i;
	}
}
```

## 선택 정렬 (Selection Sort)

셀렉션 알고리즘 (Selection Algorithm)

- k번째로 큰 or 작은 값을 찾는 알고리즘
- 최소값을 이용하여 앞과 자리를 바꾼다

<aside>
💡 버블 정렬 : 사이클마다 Swap arr.length번
선택 정렬 : 사이클마다 Swap 1번

</aside>

- 사이클 수 = 배열 - 1

## 카운팅 정렬 (Counting Sort)

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 가장 효율적인 알고리즘이지만 정수에 대해서만 적용 가능
- O(n + k) :  n은 배열의 길이, k는 정수의 최대값
- 안정 정렬
    - 중복된 원소가 정렬 후에도 입력 순서를 유지

---

## 2차원 배열

- 1차원 배열을 여러개 담을 수 있는 자료구조
- 순회, 델타 배열
- 3차원 ….  4차원 …. N차원

### 2차원 배열의 선언

- 세로(행), 가로(열)

```java
int[][] twoDimArr = new int[2][4];
int[][] twoDimArr = new int[2][];
// 열의 길이가 서로 다를 수 있음
```

| 0  | 1 | 2 | 3 |
| --- | --- | --- | --- |
| 4 | 5 | 6 | 7 |

## 배열 순회

- n*m 배열의 n*m개의 모든 원소를 조사하는 법
- 행 우선 순회

```java
for(int i = 0 ; i < n; i++){
	for(int j = 0 ; j < m; j++){	
		arr[n][m];
	}
}
```

- 열 우선 순회

```java
for(int column = 0; column < m; column++){
	for(int row = 0; row < n; row++){
		arr[row][column];;
	}
}
```

- 지그재그 순회

```java
column + (m - 1 - 2 * column) * (column % 2)
```

- 델타 사용

```java
int nr = r + dr[d];
int nc = c + dc[d];
```

- 전치 행렬
    - row < column
    

---

## String

유니코드의 적당한 외부 인코딩이 필요함

- import java.lang.String - 컴파일 시 자동 import

### 가변 길이 문자열

substring : 일부 문자 가져오기

```java
Integer.parseInt(String);
Double.parseDouble(bf.readLine());
toString() // 값 -> 문자열
```

### Brute Force

- 일일이 모두 다 비교

### 보이어 무어 알고리즘

- 뒤에서 부터 비교 길이 만큼씩 이동

### 카프-라빈 알고리즘

### KMP 알고리즘

### 시저 암호 (Caesar cipher)

---

## Stack

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 **선형 구조**
    - 선형 구조 : 자료 간의 관계가 1대1의 관계
    - 비선형 구조 : 자료 간의 관계가 1 대 N의 관계 (ex.트리)
- 마지막 삽입한 자료를 가장 먼저 꺼낸다.
- 후입 선출 (LIFO, Last-In-First-Out)

```java
stack.push(); // 삽입
stack.pop(); // 삭제
stack.isEmpty(); // 공백인지 아닌지
stack.peek(); // top에 있는 item를 반환
```

### Function call

- Stack 영역 → 실행 흐름 관리
- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서 관리
- 함수 호출(push) / 복귀(pop)

### 실행 취소 / 실행 취소의 취소

- ctrl + z
- ctrl + y.

## 계산기

- 전위 표기 : + A B
- 중위 표기 : A + B
- 후위 표기 : A B +
- 우선 순위에 따라 괄호 사용 표현
    - 연산자
        
        1) 스택이 비어있으면 push
        
        2) 스택의 Top에 우선순위가 낮은 연산자가 남을때 까지 pop
        
        3) pop한 연산자는 출력
        
    
    ### 후위 표기식 계산
    

## 재귀 호출

Base Case : 재귀 호출에서 빠져 나가기 위한 조건

Recursive case : 자신을 호출하는 부분 (Base case로 유도)

- 피보나치 수열
    - 메모리 초과
    - Memorization
        - 한번 계산했던 값은 기록
- 팩토리얼(factorial) 계산
    - N * facotrial(N - 1)

---

## Queue

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적
- 큐는 뒤에서 삽입만 하고, 큐의 앞에서만 삭제가 이뤄지는 구조 (FIFO : First In First Out)
- 머리(Front) : 마지막으로 삭제된 원소 or 제일 앞의 원소
- 꼬리(Rear) : 저장된 원소 중 마지막 원소 or 데이터가 추가될 수 있는 위치

### 연산 과정

1) 공백 큐 생성 : createQueue();

2) 원소 A 삽입 : enQueue(A);

3) 원소 반환 / 삭제 : deQueue();

### 초기 공백 큐  생성

- front , rear = -1;
- 삽입시 rear + 1
- 삭제시 front + 1

```java
 		// 삽입
		queue.add(1); // 예외 발생
		queue.offer(1);
		
		// 삭제
		queue.remove(); // 예외 발생
		queue.poll();
		
		// 조회
		queue.element(); // 예외 발생 
		queue.peek();
```

### 선형 큐 이용시 문제점

- 포화상태가 되어 더 이상의 삽입을 하지 못함

### 해결 방법

- 연산이 이뤄질 때마다 모든 원소를 앞부분으로 이동시킴
    - 효율성이 급격히 떨어짐
- 처음과 끝이 연결되도록 원형 형태의 큐 사용
- 환형 큐 , 원형 큐
- (index + 1) % length

### 큐의 활용 : 버퍼(Buffer)

- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리 영역
- 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작

### 원형 큐

- 초기 공백 상태
    - front = rear = 0
- Index의 순환
    - 마지막 인덱스 N - 1을 가리킨 후, 순환을 해 처음 인덱스 0으로 이동
    - 이를 위해 나머지 연산자 mod (%) 를 사용
    
    > front : 데이터가 마지막으로 삭제된 위치
    > 
    
    > rear : 데이터가 마지막으로 추가된 위치
    > 
- 크기가 N인 배열에서 데이터의 개수 N - 1

## 우선 순위 큐

- 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 나가게 된다
- 적용 분야
    - 네트워크 트래픽 제어
    - 시뮬레이션 시스템
    - 운영체제의 테스크
- 원소를 삽입하는 과정에서 우선순위를 비교 적절한 위치에 삽입
- 문제점
    - 삽입이나 삭제 연산이 일어나면 원소의 재배치
    - 이에 소요되는 시간과 메모리 낭비가 큼

## 삽입 정렬 (Insertion Sort)

- 부분 집합 S : 정렬된 앞 부분 원소들
- 부분 집합 U : 아직 정렬되지 않은 정렬할 원소들
- 정렬된 S의 마지막 원소부터 비교하면서 위치를 찾고 삽입
- S의 원소를 하나씩 늘리고 U의 원소를 하나씩 감소. U가 공집합이 되면 삽입 정렬 완성
- 어떤 상황에 삽입 정렬이 좋은가?
    - 이미 정렬된 데이터가 있고 새로 데이터가 추가되는 경우

---

## LinkedList

### 선형 자료 구조

- 연결리스트
- Singly Linked List
- Doubly Linked List

논리적 : 사람이 이해하는 구조

물리적 : 실제 컴퓨터 메모리 상의 저장 되는 구조

- 노드
    - 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
    1. 데이터 필드
        - 원소의 값을 저장하는 자료구조
        - 저장할 원소의 종류나 크기에 따라 구조를 정의해 사용
    2. 링크 필드
        - 다음 노드의 주소를 저장하는 자료구조
- 헤드 (특수한 노드)
    - 리스트의 처음 노드를 가리키는 래퍼런스

### 단순 연결 리스트 (Singly Linked List), 단방향

- 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
- 최종적으로 NULL을 가리키는 노드가 리스트의 마지막 노드

### 이중 연결 리스트 (Doubly Linked List), 양방향

- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 두 개의 링크 필드와 한 개의 데이터 필드로 구성

### 리스트를 이용한 스택

- push : addLast()
- pop : remove(size - 1)

### 리스트를 이용한 큐

- 삽입 : addLast()
- 삭제 : remove(0)
- 연결 리스트 → 크기를 동적으로 조절 가능
- 공백 검사
    - front = rear = null ⇒ ([head.next](http://head.next) == tail)

|  | 배열 | 리스트 |
| --- | --- | --- |
| 조회 | 빠름 O(1) | 순차 탐색 느리다 O(N) |
| 삽입 | 재배치 필요 O(N) | 연결 관계 재설정 O(1) |
| 삭제 | 재배치 필요 O(N) | 연결 관계 재설정 O(1) |

---

## Tree

- 비선형 자료구조 1 : N
- 원소들 간 계층 관계를 가지는 계층형 자료구조
- 상위 원소에서 하위 원소로 내려가는 나무 모양의 구조
- 최상위 노드 루트(root)
- 형제 노드 (sibling node) : 부모를 공유하는 노드들끼리
- 조상 노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드 ↔ 자손 노드

### 차수 (degree)

- 노드의 차수 : 노드에 연결된 자식 노드의 수
- 트리의 차수 : 트리에 있는 노드의 차수 중 가장 큰 값
- 단말 노드 (리프 노드) : 차수가 0인 , 자식이 없는 노드

### 높이

- 노드의 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 레벨
- 트리의 높이 : 트리에 있는 노드의 높이 중에 가장 큰 값. 최대 레벨

## 이진 트리

- 모든 노드들이 2개의 서브 트리를 갖는 형태
- 각 노드가 자식 노드를 최대 2개 까지만 가질 수 있는 트리
- BST ( binary search tree )
- Heap
- Segment Tree

## 포화 이진 트리

- 모든 레벨에 노드가 포화 상태
- 높이가 h일 때, 최대 노드 개수인 2^(h+1) - 1개의 노드

### 완전 이진 트리

- 높이가 h이고 노드 n개 일 때 , 1번부터 n번까지 빈 자리가 없는 이진트리 ⇒ 왼쪽부터 채워진다.
- 배열로 표현하면 효율적

### 편향 이진 트리

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만 가진 이진 트리
    - 왼쪽 편향 이진 트리
    - 오른쪽 편향 이진 트리
    - 트리로서 가치가 없다
    - 가치 있게 바꾸는 알고리즘

## 이진 트리 표현

- 배열 idx 1부터 시작해야 편하다.
- idx 0 은 더미
- 배열을 이용한 이진 트리는 트리 형태에 따라 비효율적일 수 있다
- 연결리스트를 이용해 트리를 표현할 수 있다

```java
class Node{
	int data;
	Node left;
	Node right;
}
```

## 순회

- 전위 순회 (preorder traversal) - VLR
- 중위 순회 (inorder traversal) - LVR
- 후위 순회 (postorder traversal) - LRV
    
    L - Left / R - Right / V - Vertex
    

---

## Heap

### 수식 트리

- 수식을 표현하는 이진 트리
- 수식 이진 트리 (Expression Binary Tree)
- 루트 노드 or 가지 노드는 연산자
- 피연산자는 Leaf Node

```java
double eval(nodes[root]) {
	double A = eval(root.left);
	double B = eval(root.right);
	return A B;
}
```

### 힙

- **완전 이진 트리**
- 부모 > 자식 → 최대 힙 or  부모 < 자식 → 최소 힙
- 루트가 최소 값이거나 최대 값이어야 힙

### 최대 힙 Max heap

- 루트 : 최대 값

### 최소 힙 Min heap

- 루트 : 최소 값

### 삽입

1. 완전 이진 트리 형태를 유지 / 마지막 자리 삽입
2. 정렬 조건 만족하도록 SWAP

### 삭제

## 우선순위 큐

- 우선순위 큐를 구현하는 가장 효율적인 방법은 힙 사용
- O(logN)
- java.util.PriorityQueue

### 힙 정렬

- O(NlogN)

---

- 배열
- 문자열
- 스택
- 큐
- 연결 리스트
- 트리

### 복잡도 분석

- Big-Oh 표기
    - O 표기는 복잡도의 점근적 상한을 나타냄
    - “적어도 이만큼 시간이 걸린다”
- Big-Omega 표기
    - 점근적 하한
    - “최소한 이만큼 시간이 걸린다”
- Theta-표기
    - 평균적

### 비트 연산자

- & - 비트 단위 AND 연산
- | - 비트 단위 OR 연산
- ^ - 비트 단위 XOR 연산 ( 같으면 0 다르면 1 )
- ~ - 단항 연산자 모든 비트를 반전
- << - 비트 열을 왼쪽으로 이동
- >> - 비트 열을 오른쪽으로 이동

### 부분 집합의 수

- 공 집합 포함 2^N
- 1 << N

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/acb4bbd9-5e7a-4411-b76d-2d71e461f3cd/27a54f54-18d5-4ac3-9316-fd8a8dac7648/Untitled.png)

# 분할 정복

- 분할 정복
    - 분할 (Divide) 해결할 문제를 여러 개의 작은 부분으로 나눈다
    - 정복 (Conquer) 나눈 작은 문제를 각각 해결
    - 통합 (Combine) 해결된 해답을 모은다
- 이진 검색
    - 이진 검색을 위한 조건 : 정렬이 되어 있어야 한다
- 병합 정렬
    - 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
    - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
    - top-down 방식
    - 안정 정렬
- 퀵 정렬
    - 주여진 배열을 두 개로 분할, 각각을 정렬
    - 병합 정렬과 다른 점
        - 기준 아이템 (pivot item) 중심으로 정렬
        - 병합이 필요하지 않음

## 백트래킹

- 유망성 검사 후 유망(promising)하지 않다면 노드의 부모로 되돌아감 (backtracking)
- 가지치기 (pruning)

### 백트래킹과 깊이 우선 탐색(DFS)의 차이

- 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임
- 깊이 우선 탐색은 모든 경로를 추적하는데 백트래킹은 불필요한 경로를 조기에 차단
